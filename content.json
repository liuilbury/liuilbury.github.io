[{"title":"斐波那契的通项公式及BSGS算法","date":"2019-03-02T12:32:25.000Z","path":"2019/03/02/斐波那契的通项公式及BSGS算法/","text":"BSGS是用于求解一些已知n次幂求n的算法 与zyf在上课时，想到：能不能在模条件下求一个数字是斐波那契的第几项(取最小)。在网上发现了可以解决这个问题的方法。 我了解到，斐波那契是有通项公式的。 求解斐波那契的通项公式求通项公式有好多种方法，在这里，我只会只讲一个方法 一个标准的斐波那契数列，为\\(F[n]=F[n-1]+F[n-2]\\) 先设两个变量，a,b,使得等式：\\(F[n]-aF[n-1]=b(F[n-1]-aF[n-2])\\)成立。0 然后将其化简，得到\\(F[n]=(a+b)F[n-1]-abF[n-2]\\) 所以可以知道a、b的关系：\\(\\begin{cases} a+b = 1\\\\a*b = -1\\ \\end{cases}\\) 接着写后面的n-2项:\\(F[n]-aF[n-1]=b(F[n-1]-aF[n-2])\\)\\(F[n-1]-aF[n-2]=b(F[n-2]-aF[n-3])\\)\\(F[n-2]-aF[n-3]=b(F[n-3]-aF[n-4])\\)\\(…\\)\\(F[3]-aF[2]=b(F[2]-aF[1])\\)合并得到：\\(F[n]-aF[n-1]=b^(n-2)(F[2]-aF[1])\\)\\(\\because F[1]=F[2]=1,a+b=1\\)\\(\\therefore F[2]-aF[1]=b,F[n]=b^{n-1}+aF[n-1]\\) 再接着写后面的n-1项:\\(F[n]=b^{n-1}+aF[n-1]\\)\\(F[n-1]=b^{n-2}+aF[n-2]\\)\\(F[n-2]=b^{n-3}+aF[n-3]\\)\\(…\\)\\(F[2]=b+aF[1]\\)合并——得到:\\(F[n]=b^{n-1}+ab^{n-2}+a^{2}b^{n-3}+…+a^{n-2}b+a^{n-1}\\)不难发现这是一个等比数列，公比为\\(\\frac{a}{b}\\)。所以用等比数列求和式子得到F[n]的表达式——\\[F[n]=\\frac{b^{n}-a^{n}}{b-a}\\]通过\\(a+b=1\\)和\\(ab=-1\\),可以解出\\(a=\\frac{1+\\sqrt{5}}{2}\\)\\(b=\\frac{1-\\sqrt{5}}{2}\\) 所以——\\[F[n]=\\frac{1}{\\sqrt{5}}\\left [\\left ( \\frac{1+\\sqrt{5}}{2} \\right )^{n} +\\left ( \\frac{1-\\sqrt{5}}{2} \\right )^{n}\\right ]\\] BSGS算法BSGS(BABY-STEP GIANT-STEP)用于解决高次同余方程的问题。形如\\(a^x=b (mod p)\\)已知a,b,p求x。这里，我们仅考虑p为质数的情况。由欧拉定理可知，在同余p的条件下，x的取值范围在[0,p);当p比较小的时候，我们自然可以暴力遍历x，但是当p很大的时候呢？单纯的暴力太慢了，我们得想个加速的方法。如果我们想求一个数的因子，只需要枚举它的小的那个因子就可以了，遍历1到\\(\\sqrt{p}\\)。那么对于这个方程，我们同样使用这个思想。首先，枚举x从1到\\(\\sqrt{p}\\)，求出\\(a^{x}\\)的值，那么我们就得到了\\(\\sqrt{p}\\)个\\(a^{x}\\)的值，并且可以知道这些值里面有没有同余b的存在。如果有，那这就是最小的x；如果没有怎么办？试想一下，\\(a^{1}*a^{2} = a^{3}\\)。 那么，\\(a^{1}*a^{\\sqrt{p}} = a^{p+1}\\)。现在我们已知\\(a^{1}到a^{\\sqrt{p}}\\)的值，我们将他们都乘\\(a^{\\sqrt{p}}\\),我们就得到了\\(a^{1+\\sqrt{p}}到a^{\\sqrt{p}+\\sqrt{p}}\\)的值。但是，如果遍历\\(\\sqrt{p}\\)个数，将他们更新，时间复杂度还是为\\(O(n)\\)的，这个\\(a^{\\sqrt{p}}\\)，我们可不可以将这个\\(a^{\\sqrt{p}}\\)移到等式左边去，也就是说，让b除以\\(a^{\\sqrt{p}}\\)，这不是一样的么。 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define fi first #define se second #define mem(a, b) memset(a, b, sizeof(a)) #define INF 0X3f3f3f3f const ll MAXN = 5000 + 7; const ll MOD = 1e9 + 7; //-------------------------------------------// unordered_map&lt;ll, ll&gt; mp; ll quickpow(ll a, ll b, ll c) { ll ans = 1; while (b != 0) { if (b &amp; 1) { ans = (ans * a) % c; } a = (a * a) % c; b &gt;&gt;= 1; } return ans % c; } ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if (b == 0) { x = 1; y = 0; return a; } ll r = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b * y; return r; } ll bsgs(ll a, ll b, ll p) { a %= p; b %= p; if (a == 0) return b == 0 ? 1 : -1; if (b == 1) return 0; ll t = ceil(sqrt(p)), inv,m; exgcd(quickpow(a, t, p), p, inv, m); inv = (inv % p + p) % p; mp.clear(); mp[1] = 0; for (ll i = 1, ans = 1; i &lt; t; i++) { ans = ans * a % p; if (mp.find(ans) == mp.end()) mp[ans] = i; } for (ll i = 0; i &lt; t; i++) { if (mp.find(b) != mp.end()) return i * t + mp[b]; else b = b * inv % p; } return -1; } int main() { ll p, b, n; while (scanf(&quot;%lld%lld%lld&quot;, &amp;p, &amp;b, &amp;n) != EOF) { ll res = bsgs(b, n, p); if (res != -1) printf(&quot;%lld\\n&quot;, res); else puts(&quot;no solution&quot;); } return 0; } #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; #define fi first #define se second #define mem(a, b) memset(a, b, sizeof(a)) #define INF 0X3f3f3f3f const ll MAXN = 5000 + 7; const ll MOD = 1e9 + 7; //——————————————-// unordered_map&lt;ll, ll&gt; mp; ll quickpow(ll a, ll b, ll c) { ll ans = 1; while (b != 0) { if (b &amp; 1) { ans = (ans a) % c; } a = (a a) % c; b &gt;&gt;= 1; } return ans % c; } ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if (b == 0) { x = 1; y = 0; return a; } ll r = exgcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b y; return r; } ll bsgs(ll a, ll b, ll p) { a %= p; b %= p; if (a == 0) return b == 0 ? 1 : -1; if (b == 1) return 0; ll t = ceil(sqrt(p)), inv,m; exgcd(quickpow(a, t, p), p, inv, m); inv = (inv % p + p) % p; mp.clear(); mp[1] = 0; for (ll i = 1, ans = 1; i &lt; t; i++) { ans = ans a % p; if (mp.find(ans) == mp.end()) mp[ans] = i; } for (ll i = 0; i &lt; t; i++) { if (mp.find(b) != mp.end()) return i t + mp[b]; else b = b inv % p; } return -1; } int main() { ll p, b, n; while (scanf(&quot;%lld%lld%lld&quot;, &amp;p, &amp;b, &amp;n) != EOF) { ll res = bsgs(b, n, p); if (res != -1) printf(&quot;%lld\\n&quot;, res); else puts(&quot;no solution&quot;); } return 0; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;","tags":[{"name":"算法","slug":"算法","permalink":"http://liulibury.top/tags/算法/"},{"name":"数论","slug":"数论","permalink":"http://liulibury.top/tags/数论/"},{"name":"基本数学","slug":"基本数学","permalink":"http://liulibury.top/tags/基本数学/"}]},{"title":"后缀数组和后缀自动机","date":"2019-02-26T10:34:52.000Z","path":"2019/02/26/后缀数组和后缀自动机/","text":"整理归纳复习和巩固一下后缀相关的算法。 后缀数组(suffix array)一开始接触后缀数组的时候，只是鶸在多校的一道题目，大佬说用后缀数组写，然后就去百度学，后来发现其实可以用kmp找循环节就能过，就将后缀数组搁浅了(大佬到最后也没用后缀数组过，tle了)。到如今，我也没有用后缀数组在比赛中通过一道题目，后缀数组的题目也寥寥无几。也许这是被时代所抛弃的一个算法吧233。感想说到这里，该进入正题了。后缀数组，顾名思义，是用数组处理后缀字符串的一种算法。但是它的不仅可以用于后缀和字符串，一些涉及到子串和数组的题目，也是能用后缀数组解决的。后缀数组的目的，是将所有后缀进行快速的排序。由于其本身和后缀树的 dfs 序有一定联系，也有很多很好的性质，在其上建立了很多的算法。后缀数组的算法常用的有两种，倍增法和dc3法。还有刚刚了解到的SA-IS法。 倍增法倍增法算是求后缀数组的最咸鱼简单的方法了。它的时间复杂度为\\(O(NlogN)\\) 我们先了解几个数组：SA数组：后缀数组的最后目标————对后缀串进行排序以后每个名次的位置。例如字符串”ABBA”，排序完成后的SA数组为：SA[1]=4,SA[2]=1,SA[3]=3,SA[4]=2。rank数组：在进行排序时候的辅助，一个强壮的大哥背后一定有个兢兢业业的好辅助，表示对后缀串进行排序以后每个位置的名次，与SA数组取反：rank[1]=2,rank[2]=4,rank[3]=3,rank[4]=1。height数组：记录sa[i]和sa[i-1]的最长公共前缀长度。再了解一个叫基数排序的东西： 百度百科：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。以LSD为例，假设原来有一串数值如下所示：73, 22, 93, 43, 55, 14, 28, 65, 39, 81首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：01 812 223 73 93 434 145 55 65678 289 39第二步接下来将这些桶子中的数值重新串接起来，成为以下的数列：81, 22, 73, 93, 43, 14, 55, 65, 28, 39接着再进行一次分配，这次是根据十位数来分配：01 142 22 283 394 435 556 657 738 819 93第三步接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。 好的，再了解完基数排序后，我们就可以进入后缀数组的排序啦(鼓掌~)。既然数字可以按照每位进行基数排序，那么后缀是不是也可以按照每位的字符这样操作呢？","tags":[{"name":"算法","slug":"算法","permalink":"http://liulibury.top/tags/算法/"},{"name":"字符串","slug":"字符串","permalink":"http://liulibury.top/tags/字符串/"},{"name":"自动机","slug":"自动机","permalink":"http://liulibury.top/tags/自动机/"}]},{"title":"博客更新日志","date":"2019-02-26T10:34:52.000Z","path":"2019/02/26/更新日志/","text":"闲来无事搞个博客，功能简陋，等待更新。 2018/2/281.重新选择了博客的主题2.加入了很多图片什么的3.。。。 2019/2/271.初步加入了live2d2.由于背景透明的缘故，导致live2d也透明，正在解决。 2019/2/261.背景透明2.苦心爬下来的背景图片","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://liulibury.top/tags/杂谈/"}]}]